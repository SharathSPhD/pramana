#!/usr/bin/env python3
"""
Extract Z3 encodings from vyapti_benchmark_z3_encodings.md into standalone .py files.

Each extracted file:
- Keeps the original code exactly as-is
- Adds a check() function that captures print output and returns {output, problem_id}
- Has an if __name__ == "__main__" block that calls check() and prints the result

Also creates __init__.py with REGISTRY and get_encoding().
"""

import re
from pathlib import Path


def problem_id_to_module_name(problem_id: str) -> str:
    """Convert problem ID to module filename (lowercase, dash to underscore)."""
    return problem_id.lower().replace("-", "_")


def extract_problem_id(header_line: str) -> str | None:
    """Extract problem ID from ### or ## header line."""
    # ### SAV-01 — Engineering Remote Work  -> SAV-01
    # ### SAV-01-C — Control (Counterexample Removed)  -> SAV-01-C
    # ## UTILITY: Generic Vyāpti Checker  -> UTILITY
    header_line = header_line.strip()
    if header_line.startswith("### "):
        rest = header_line[4:].strip()
        # Split on em dash or regular dash with spaces
        match = re.match(r"^([A-Z]{2,4}-[\dA-Z\-]+)\s*[—\-]\s*", rest)
        if match:
            return match.group(1)
        # Fallback: take first token (e.g. SAV-01-C)
        parts = re.split(r"\s+[—\-]\s+", rest, 1)
        return parts[0].strip() if parts else None
    if header_line.startswith("## "):
        rest = header_line[3:].strip()
        # ## UTILITY: Generic Vyāpti Checker
        if rest.upper().startswith("UTILITY"):
            return "UTILITY"
        # Other ## headers - take first word before :
        match = re.match(r"^([A-Za-z_]+)", rest)
        if match:
            return match.group(1)
    return None


def parse_markdown(content: str) -> list[tuple[str, str]]:
    """Parse markdown and return list of (problem_id, code) tuples."""
    results = []
    lines = content.split("\n")
    i = 0
    last_problem_id = None

    while i < len(lines):
        line = lines[i]
        # Check for ### or ## headers
        if line.startswith("### ") or (line.startswith("## ") and not line.startswith("## " * 2)):
            problem_id = extract_problem_id(line)
            if problem_id:
                last_problem_id = problem_id
        # Check for ```python code block
        elif line.strip() == "```python" and last_problem_id:
            i += 1
            code_lines = []
            while i < len(lines) and lines[i].strip() != "```":
                code_lines.append(lines[i])
                i += 1
            if code_lines:
                code = "\n".join(code_lines)
                results.append((last_problem_id, code))
            # Don't clear last_problem_id - next block might have same header
        i += 1

    return results


def make_encoding_module(problem_id: str, code: str) -> str:
    """Generate the full .py module content with check() wrapper."""
    # Use ''' for code wrapper to allow """ in code (e.g. docstrings)
    if "'''" in code:
        raise ValueError(f"Code for {problem_id} contains ''' - cannot embed safely")
    tq = "'''"  # Avoid nested ''' in template
    template = f'''"""Z3 encoding for PROBLEM_ID_PLACEHOLDER — auto-extracted from vyapti_benchmark_z3_encodings.md"""

PROBLEM_ID = "PROBLEM_ID_PLACEHOLDER"


def check():
    """Run the encoding, capture print output, return dict with output and problem_id."""
    import sys
    from io import StringIO

    old_stdout = sys.stdout
    sys.stdout = StringIO()
    try:
        exec(compile(_CODE, "<encoding>", "exec"))
        output = sys.stdout.getvalue()
    finally:
        sys.stdout = old_stdout
    return {{"output": output, "problem_id": PROBLEM_ID}}


_CODE = {tq}
CODE_PLACEHOLDER
{tq}


if __name__ == "__main__":
    result = check()
    print(result)
'''
    return template.replace("PROBLEM_ID_PLACEHOLDER", problem_id).replace(
        "CODE_PLACEHOLDER", code
    )


def main():
    md_path = Path("/home/sharaths/projects/pramana/docs/vyapti/vyapti_benchmark_z3_encodings.md")
    out_dir = Path("/home/sharaths/projects/pramana/data/vyapti_probe/z3_encodings")
    out_dir.mkdir(parents=True, exist_ok=True)

    content = md_path.read_text()
    extractions = parse_markdown(content)

    seen_ids = set()
    registry_entries = []
    for problem_id, code in extractions:
        module_name = problem_id_to_module_name(problem_id)
        module_content = make_encoding_module(problem_id, code)
        out_path = out_dir / f"{module_name}.py"
        out_path.write_text(module_content, encoding="utf-8")

        if problem_id not in seen_ids:
            seen_ids.add(problem_id)
            registry_entries.append(f'    "{problem_id}": "{module_name}",')

    init_content = f'''"""Z3 encodings for Vyāpti Probe Benchmark — auto-generated by extract_z3_encodings.py"""

REGISTRY = {{
{chr(10).join(registry_entries)}
}}


def get_encoding(problem_id: str):
    """Import and return the module for the given problem ID."""
    import importlib
    module_name = REGISTRY.get(problem_id)
    if module_name is None:
        raise KeyError(f"No encoding for problem_id: {{problem_id!r}}")
    return importlib.import_module(f".{{module_name}}", __name__)
'''

    init_path = out_dir / "__init__.py"
    init_path.write_text(init_content, encoding="utf-8")

    return len(extractions)


if __name__ == "__main__":
    n = main()
    print(f"Extracted {n} Z3 encoding files")
